import { NextResponse } from 'next/server';
import { GoogleGenAI, GenerateContentResponse } from '@google/genai';

// Sprawdzamy dostƒôpno≈õƒá klucza API w spos√≥b bardziej widoczny
const apiKey = process.env.GEMINI_API_KEY || '';
console.log(`Klucz API Gemini dostƒôpny: ${apiKey ? 'TAK' : 'NIE'}`);

if (!apiKey) {
  console.error('‚ùå B≈ÅƒÑD: Brak klucza API Gemini (GEMINI_API_KEY)!');
}

// Inicjalizacja klienta Google Gen AI tylko gdy klucz jest dostƒôpny
let ai: any = null;
try {
  if (apiKey) {
    ai = new GoogleGenAI({ apiKey });
    console.log('‚úÖ Klient GoogleGenAI zainicjalizowany');
  }
} catch (error) {
  console.error('‚ùå B≈ÇƒÖd inicjalizacji GoogleGenAI:', error);
}

// Dodajemy Cache dla ostatnich zapyta≈Ñ, aby uniknƒÖƒá podw√≥jnego wywo≈Çywania API
const requestCache = new Map<string, Promise<NextResponse>>();
// Czas wyga≈õniƒôcia cache w milisekundach (5 sekund)
const CACHE_EXPIRY = 5000;

// Interfejs dla pytania
interface Question {
  id: number;
  question: string;
  tips: string[];
}

// Interfejs dla odpowiedzi JSON z API
interface QuestionsResponse {
  questions: Question[];
}

// Funkcja pomocnicza do generowania przyk≈Çadowych pyta≈Ñ (awaryjnie)
function generateFallbackQuestions(position: string, companyName: string): Question[] {
  return [
    {
      id: 1,
      question: `Jakie do≈õwiadczenie w zakresie ${position} Pan/Pani posiada?`,
      tips: [
        "Skup siƒô na najbardziej istotnych do≈õwiadczeniach",
        "Podaj konkretne przyk≈Çady projekt√≥w",
        "Wymie≈Ñ umiejƒôtno≈õci, kt√≥re sƒÖ istotne dla tego stanowiska",
        "Wspomnij o sukcesach w poprzednich rolach"
      ]
    },
    {
      id: 2,
      question: `Dlaczego chce Pan/Pani pracowaƒá w firmie ${companyName}?`,
      tips: [
        "Poka≈º, ≈ºe znasz firmƒô i jej warto≈õci",
        "Wyja≈õnij, jak Twoje cele zawodowe sƒÖ zgodne z firmƒÖ",
        "Podkre≈õl aspekty kultury firmy, kt√≥re Ci odpowiadajƒÖ",
        "BƒÖd≈∫ szczery i autentyczny w swojej motywacji"
      ]
    },
    {
      id: 3,
      question: "Jak radzi sobie Pan/Pani w sytuacjach stresowych?",
      tips: [
        "Podaj konkretny przyk≈Çad trudnej sytuacji z przesz≈Ço≈õci",
        "Opisz kroki, kt√≥re podjƒÖ≈Çe≈õ/podjƒô≈Ça≈õ, aby poradziƒá sobie ze stresem",
        "Wyja≈õnij, jakie techniki stosujesz do zarzƒÖdzania stresem",
        "Podkre≈õl swoje umiejƒôtno≈õci adaptacji i rozwiƒÖzywania problem√≥w"
      ]
    }
  ];
}

export async function POST(req: Request) {
  console.log('üîÑ Rozpoczƒôcie obs≈Çugi ≈ºƒÖdania POST do /api/interview-questions');
  
  if (!apiKey || !ai) {
    console.error('‚ùå Brak klucza API lub klient nie zosta≈Ç zainicjalizowany');
    return NextResponse.json({
      success: true, // Oznaczamy jako sukces, aby nie przerywaƒá flow aplikacji
      error: 'Konfiguracja API niekompletna: Brak klucza API Gemini',
      questions: generateFallbackQuestions("tego stanowiska", "tej firmie")  // Zwracamy awaryjne pytania
    });
  }

  try {
    // Debugowanie nag≈Ç√≥wk√≥w i metody ≈ºƒÖdania 
    console.log('Metoda ≈ºƒÖdania:', req.method);
    console.log('Nag≈Ç√≥wki ≈ºƒÖdania:', Object.fromEntries(req.headers.entries()));
    
    // Sprawdzamy, czy request jest prawid≈Çowy JSON
    let body;
    try {
      body = await req.json();
    } catch (parseError) {
      console.error('‚ùå B≈ÇƒÖd parsowania JSON z body:', parseError);
      return NextResponse.json({ 
        success: false, 
        error: 'Nieprawid≈Çowy format danych',
        questions: generateFallbackQuestions("tego stanowiska", "tej firmie")
      }, { status: 400 });
    }
    
    const { companyName, position, description } = body;
    console.log(`üìù Otrzymano dane: firma=${companyName}, stanowisko=${position}`);
    
    if (!companyName || !position) {
      console.warn('‚ö†Ô∏è Brak nazwy firmy lub stanowiska');
      return NextResponse.json({ 
        success: false, 
        error: 'Brak nazwy firmy lub stanowiska',
        questions: generateFallbackQuestions("tego stanowiska", "tej firmie") 
      }, { status: 400 });
    }

    // Tworzymy klucz cache na podstawie parametr√≥w zapytania
    const cacheKey = `${companyName}-${position}-${description || ''}`;
    
    // Sprawdzamy, czy takie zapytanie jest ju≈º w cache
    if (requestCache.has(cacheKey)) {
      console.log(`üìã U≈ºywam zcachowanej odpowiedzi dla: ${position} w ${companyName}`);
      return await requestCache.get(cacheKey)!;
    }

    console.log(`üîç Generowanie pyta≈Ñ rekrutacyjnych dla: ${position} w ${companyName}`);

    // Funkcja do faktycznego przetworzenia zapytania
    const processRequest = async () => {
      try {
        const prompt = `Wygeneruj 15 profesjonalnych pyta≈Ñ rekrutacyjnych, kt√≥re mogƒÖ pojawiƒá siƒô podczas rozmowy o pracƒô na stanowisko ${position} w firmie ${companyName}.
        
        Pytania powinny nale≈ºeƒá do nastƒôpujƒÖcych kategorii:
        1. Pytania o do≈õwiadczenie zawodowe kandydata (4 pytania)
        2. Pytania o umiejƒôtno≈õci techniczne i kompetencje zwiƒÖzane ze stanowiskiem (3 pytania)
        3. Pytania behawioralne i sytuacyjne (3 pytania)
        4. Pytania o motywacjƒô i dopasowanie do firmy ${companyName} (3 pytania)
        5. Pytania o oczekiwania i plany zawodowe (2 pytania)
        
        Opis stanowiska (je≈õli dostƒôpny): ${description || 'Brak szczeg√≥≈Çowego opisu'}
        
        Dla ka≈ºdego pytania dodaj 4 kr√≥tkie wskaz√≥wki, jak najlepiej na nie odpowiedzieƒá.
        
        Odpowiedz w formacie JSON w jƒôzyku polskim zgodnym z poni≈ºszym schematem:
        {
          "questions": [
            {
              "id": 1,
              "question": "Tre≈õƒá pytania 1",
              "tips": ["Wskaz√≥wka 1", "Wskaz√≥wka 2", "Wskaz√≥wka 3", "Wskaz√≥wka 4"]
            },
            {
              "id": 2,
              "question": "Tre≈õƒá pytania 2",
              "tips": ["Wskaz√≥wka 1", "Wskaz√≥wka 2", "Wskaz√≥wka 3", "Wskaz√≥wka 4"]
            }
          ]
        }`;

        console.log('üìù Wysy≈Çanie zapytania do Gemini API');
        
        // Spr√≥buj u≈ºyƒá API Gemini - dodajemy obs≈Çugƒô b≈Çƒôdu CORS
        try {
          // Dodajemy timeout na wypadek, gdyby API nie odpowiedzia≈Ço
          const timeoutPromise = new Promise<GenerateContentResponse | null>((resolve) => {
            setTimeout(() => {
              console.warn('‚ö†Ô∏è Timeout - brak odpowiedzi z Gemini API');
              resolve(null);
            }, 15000); // 15 sekund timeout
          });

          // Wywo≈Çujemy faktyczne zapytanie do Gemini
          const apiPromise = ai.models.generateContent({
            model: 'gemini-2.0-flash',
            contents: [{ text: prompt }],
          });
          
          // U≈ºywamy Promise.race aby obs≈Çu≈ºyƒá timeout
          const result = await Promise.race([apiPromise, timeoutPromise]);
          
          if (!result) {
            throw new Error('Timeout - API nie odpowiada w oczekiwanym czasie');
          }

          const candidates = result.candidates;
          if (!candidates || candidates.length === 0) {
            console.warn('‚ö†Ô∏è Brak kandydat√≥w w odpowiedzi Gemini, u≈ºywam zapasowych pyta≈Ñ');
            return NextResponse.json({
              success: true,
              questions: generateFallbackQuestions(position, companyName)
            });
          }

          const first = candidates[0];
          const text = first.content?.parts?.[0]?.text || '';

          if (!text.trim()) {
            console.warn("‚ö†Ô∏è Gemini nie wygenerowa≈Ço tekstu, u≈ºywam zapasowych pyta≈Ñ");
            return NextResponse.json({
              success: true,
              questions: generateFallbackQuestions(position, companyName)
            });
          }

          console.log("‚úÖ Wygenerowano tekst z pytaniami rekrutacyjnymi");
          
          // Pr√≥ba parsowania JSON z odpowiedzi tekstowej
          try {
            // Szukanie obiektu JSON w tek≈õcie (mo≈ºe byƒá poprzedzony lub zako≈Ñczony dodatkowym tekstem)
            const jsonMatch = text.match(/\{[\s\S]*"questions"[\s\S]*\}/);
            
            if (jsonMatch) {
              const jsonStr = jsonMatch[0];
              const parsedData: QuestionsResponse = JSON.parse(jsonStr);
              
              console.log("‚úÖ Zparsowano JSON z pytaniami rekrutacyjnymi");
              
              return NextResponse.json({
                success: true,
                questions: parsedData.questions
              });
            } else {
              console.warn("‚ö†Ô∏è Nie znaleziono obiektu JSON w odpowiedzi, u≈ºywam zapasowych pyta≈Ñ");
              console.log("Odpowied≈∫ API:", text);
              return NextResponse.json({
                success: true,
                questions: generateFallbackQuestions(position, companyName)
              });
            }
          } catch (parseError) {
            console.error("‚ùå B≈ÇƒÖd parsowania JSON:", parseError);
            // Zapisujemy pe≈ÇnƒÖ odpowied≈∫ API do debugowania
            console.log("Odpowied≈∫ API:", text);
            return NextResponse.json({
              success: true,
              questions: generateFallbackQuestions(position, companyName)
            });
          }
        } catch (geminiError) {
          console.error("‚ùå B≈ÇƒÖd Gemini API:", geminiError);
          // W przypadku awarii API Gemini, zwracamy awaryjne pytania
          return NextResponse.json({
            success: true,
            questions: generateFallbackQuestions(position, companyName)
          });
        }
      } catch (innerError) {
        console.error("‚ùå Wewnƒôtrzny b≈ÇƒÖd podczas przetwarzania zapytania:", innerError);
        return NextResponse.json({
          success: true,
          questions: generateFallbackQuestions(position, companyName)
        });
      }
    };

    // Zapisujemy Promise do cache
    const responsePromise = processRequest();
    requestCache.set(cacheKey, responsePromise);
    
    // Ustawiamy timer do usuniƒôcia z cache po okre≈õlonym czasie
    setTimeout(() => {
      requestCache.delete(cacheKey);
    }, CACHE_EXPIRY);
    
    return await responsePromise;
    
  } catch (error: any) {
    console.error('‚ùå B≈ÇƒÖd podczas generowania pyta≈Ñ:', error);
    
    // W przypadku jakiegokolwiek b≈Çƒôdu zwracamy awaryjne pytania zamiast b≈Çƒôdu
    try {
      const body = await req.json();
      const { companyName = "tej firmie", position = "tego stanowiska" } = body;
      
      return NextResponse.json({
        success: true,
        questions: generateFallbackQuestions(position, companyName)
      });
    } catch (parseError) {
      // Je≈õli nawet nie mo≈ºemy odczytaƒá body, u≈ºywamy domy≈õlnych warto≈õci
      return NextResponse.json({
        success: true,
        questions: generateFallbackQuestions("tego stanowiska", "tej firmie")
      });
    }
  }
}